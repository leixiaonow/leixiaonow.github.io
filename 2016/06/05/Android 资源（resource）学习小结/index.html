<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Android 资源（resource）学习小结运用Android SDK进行UI开发时，虽然也可以使用纯代码来完成，但是那种方法对我这种刚学习Android对API还不懂的人来说，能进行类似VB、MFC一样图形化开发自然是最合适不过的。幸好Android也提供了这种方式，在Android工程文件中专门有个res目录用于存放资源，该目录下的资源可以进行可视化的编辑，编写好的资源通过AAPT（And">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2016/06/05/Android 资源（resource）学习小结/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Android 资源（resource）学习小结运用Android SDK进行UI开发时，虽然也可以使用纯代码来完成，但是那种方法对我这种刚学习Android对API还不懂的人来说，能进行类似VB、MFC一样图形化开发自然是最合适不过的。幸好Android也提供了这种方式，在Android工程文件中专门有个res目录用于存放资源，该目录下的资源可以进行可视化的编辑，编写好的资源通过AAPT（And">
<meta property="og:updated_time" content="2016-06-05T10:21:37.456Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Android 资源（resource）学习小结运用Android SDK进行UI开发时，虽然也可以使用纯代码来完成，但是那种方法对我这种刚学习Android对API还不懂的人来说，能进行类似VB、MFC一样图形化开发自然是最合适不过的。幸好Android也提供了这种方式，在Android工程文件中专门有个res目录用于存放资源，该目录下的资源可以进行可视化的编辑，编写好的资源通过AAPT（And">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android 资源（resource）学习小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/05/Android 资源（resource）学习小结/" class="article-date">
  <time datetime="2016-06-05T10:24:26.630Z" itemprop="datePublished">2016-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android-资源（resource）学习小结"><a href="#Android-资源（resource）学习小结" class="headerlink" title="Android 资源（resource）学习小结"></a>Android 资源（resource）学习小结</h1><p>运用Android SDK进行UI开发时，虽然也可以使用纯代码来完成，但是那种方法对我这种刚学习Android对API还不懂的人来说，能进行类似VB、MFC一样图形化开发自然是最合适不过的。幸好Android也提供了这种方式，在Android工程文件中专门有个res目录用于存放资源，该目录下的资源可以进行可视化的编辑，编写好的资源通过AAPT（Android AssetPackaging Tool）工具自动生成gen目录下的R.Java资源索引文件，之后在Java代码和XML资源文件中就可以利用索引来调用资源了。</p>
<p>Android提供了如此便利的资源架构，要想使用它，还是要对他有深入的了解才可以，以下就这阵子对Android资源的学习进行小结来回顾和整理几个问题</p>
<p><strong>Android资源目录结构问题？</strong></p>
<p><strong>Android资源支持哪些类型资源，他们具体的语法和使用规则？</strong></p>
<h3 id="Android资源目录结构"><a href="#Android资源目录结构" class="headerlink" title="Android资源目录结构"></a>Android资源目录结构</h3><p>Android资源除了assets目录是与res同级外，其它资源均被放在res/目录下面，该目录下面的资源文件夹并不是随意命名的，需要遵循严格的规范，否则编译生成R.java过程中会报类似“invalidresource directory name **”的错误提示，并且导致R.java自动生成失败。</p>
<p>常用的缺省目录和对应资源类型在SDK帮助中有表格列出，简单摘抄如下</p>
<table>
<thead>
<tr>
<th>目录Directory</th>
<th>资源类型Resource Types</th>
</tr>
</thead>
<tbody>
<tr>
<td>res/animator</td>
<td>存放定义了property animations（android 3.0新定义的动画框架）的XML文件</td>
</tr>
<tr>
<td>res/anim/</td>
<td>存放定义了补间动画（tweened animation）或逐帧动画（frame by frame animation）的XML文件。（该目录下也可以存放定义property animations的XML文件，但是最好还是分开存放）</td>
</tr>
<tr>
<td>res/raw/</td>
<td>存放直接复制到设备中的任意文件。它们无需编译，添加到你的应用程序编译产生的压缩文件中。要使用这些资源，可以调用Resources.openRawResource()，参数是资源的ID，即R.raw.somefilename。</td>
</tr>
<tr>
<td>res/drawable/</td>
<td>存放能转换为绘制资源（Drawable Resource）的位图文件（后缀为.png, .9.png, .jpg, .gif的图像文件)或者定义了绘制资源的XML文件</td>
</tr>
<tr>
<td>res/color/</td>
<td>存放定义了颜色状态列表资源(Color State List Resource)的XML文件</td>
</tr>
<tr>
<td>res/layout/</td>
<td>存放定义了用户界面布局的XML文件</td>
</tr>
<tr>
<td>res/menu/</td>
<td>存放定义了应用程序菜单资源的XML文件</td>
</tr>
<tr>
<td>res/values/</td>
<td>存放定义了多种类型资源的XML文件，这些资源的类型可以是字符串，数据，颜色、尺寸、样式等等，具体在后面详述</td>
</tr>
<tr>
<td>res/xml/</td>
<td>存放任意的XML文件，在运行时可以通过调用Resources.getXML()读取</td>
</tr>
</tbody>
</table>
<h4 id="资源文件夹内文件夹命名规则"><a href="#资源文件夹内文件夹命名规则" class="headerlink" title="资源文件夹内文件夹命名规则"></a>资源文件夹内文件夹命名规则</h4><p>上面说过res文件夹下的文件夹命名是有规矩的，否则会报类似“invalid resource directory name **”的错误提示，除了上表提供的缺省文件夹，一般可以用缺省文件夹名加短横线加配置相关的限定符构成需要的资源文件夹，用于区别不同屏幕分辨率、不同机型特点（是否带键盘等）以及不同的本地化资源等用处，详细参考API说明文档。具体案例如下图所示</p>
<p>其中的values-zh-rCN就是中文简体资源包，用于本地化，至于其它就对照API说明文档来分析。一般项目缺省的资源文件夹名称就够了。</p>
<h4 id="资源文件夹内的资源文件存放规则"><a href="#资源文件夹内的资源文件存放规则" class="headerlink" title="资源文件夹内的资源文件存放规则"></a>资源文件夹内的资源文件存放规则</h4><p>由上面资源表可知，每个文件夹中存放的文件类型不仅有规定，而且对文件内容也是有严格要求的，曾经将一个定义布局的spinner.xml文件放置在res/values，结果就报“Invalid start tag *Layout spinner.xml”错误，并导致R.java没有生成；将该布局文件放置在res/color下面，虽然没有报错，但是原本的布局文件，不再是正确生成为形如“R.layout.spinner”的布局资源，而是生成为了“R.color.spinner”的颜色资源索引，具体如下所示</p>
<p>布局文件放置正确的R.java中代码</p>
<pre><code>public static final class layout {

    public static final int autocomplete=0x7f030000;

    public static final int spinner=0x7f03000d;

}
</code></pre><p>布局文件放置错误的R.java中代码</p>
<pre><code>public static final class color {

    public static final int solid_blue=0x7f050001;

    public static final int spinner=0x7f050004;

}
</code></pre><p>另外当一种资源定义XML文件放在不对应的res文件夹下，在可视化环境下，也就不能正确显示和编辑。</p>
<p>通过上述一些特性，我们可以猜测出android的aapt工具的工作原理，先是根据文件夹名来进行对资源文件和XML文件，使用不同的解析和编译规则进行解析和编译，ADT工具也是根据具体文件夹名称调用不同的规则来可视化编辑和呈现。</p>
<h4 id="使用eclipse-IDE提供的框架来创建资源"><a href="#使用eclipse-IDE提供的框架来创建资源" class="headerlink" title="使用eclipse IDE提供的框架来创建资源"></a>使用eclipse IDE提供的框架来创建资源</h4><p>由于Android资源文件和文件夹有那么多的规矩，所以新手还是建议用eclipse IDE提供的创建XML文件的框架来创建资源文件和资源文件夹，即在你需要创建资源文件时，通过“File”“New”“Android XML file”就可以弹出如下的New Android XML File对话框，</p>
<p>选好工程，填好资源文件名，在“What type of resourcewould you like to create”中勾选需要创建的资源类型，假如是非缺省目录资源就在“what type of resource configuration would you like?”添加需要的配置类型，就可以在“Folder”中自动生成资源xml所在的文件夹，这个不用修改它。其它就根据需要来选择，然后点击“Finish”，就可以创建出符合规则的资源文件了。在这里需要注意的是资源文件名不能使用大写字母。</p>
<p>是不是很省事，又能做出正确的事情啊，呵呵！</p>
<h2 id="Android资源类型及其简单使用"><a href="#Android资源类型及其简单使用" class="headerlink" title="Android资源类型及其简单使用"></a>Android资源类型及其简单使用</h2><p>上面对Android的资源目录的分析中，已经大致展现了Android资源类型的大致脉络，下面从简单资源先入手详细罗列下具体的资源类型和使用。一般而言，没有明说资源不能在XML资源文件中被调用，那么该资源都是既可以在其它XML资源文件中被调用又可以在Java代码中被调用的。</p>
<h3 id="字符串常量资源（string）"><a href="#字符串常量资源（string）" class="headerlink" title="字符串常量资源（string）"></a>字符串常量资源（string）</h3><p>字符串资源位于/res/values目录下，一般定义为/res/values/strings.xml文件中（文件名随意，但是目录是固定的），主要定义的是应用程序需要用到的字串资源，这和Symbian的字串资源规划类似，不过更加进步了些。当然，你非要在代码中使用字串也可以，但那种方式并不是推荐的。字串资源有String、String Array和Quantity Strings (Plurals)三类，其各自语法和用例稍微有些区别</p>
<h4 id="String语法"><a href="#String语法" class="headerlink" title="String语法"></a>String语法</h4><pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

  &lt;string name=&quot;string_name&quot;&gt;text_string&lt;/string&gt;

&lt;/resources&gt;
</code></pre><p>上面的string_name字符串资源，可以通过如下两种方法调用</p>
<p>XML资源定义中</p>
<pre><code>@[package:]string/string_name
</code></pre><p>Java代码中</p>
<pre><code>R.string.string_name
</code></pre><h4 id="String用例"><a href="#String用例" class="headerlink" title="String用例"></a>String用例</h4><p>假设有个资源文件为res/values/strings.xml，其内容如下:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;string name=&quot;hello&quot;&gt;Hello!&lt;/string&gt;

&lt;/resources&gt;
</code></pre><p>那么这个hello字串资源在其它XML资源文件中的调用如下所示</p>
<pre><code>&lt;TextView

   android:layout_width=&quot;fill_parent&quot;

   android:layout_height=&quot;wrap_content&quot;

   android:text=&quot;@string/hello&quot;/&gt;
</code></pre><p>在java代码中的调用如下</p>
<pre><code>String string = getString(R.string.hello);
</code></pre><h3 id="String-Array的语法"><a href="#String-Array的语法" class="headerlink" title="String Array的语法"></a>String Array的语法</h3><pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;string-array name=&quot;string_array_name&quot;&gt;

   &lt;item&gt;text_string&lt;/item&gt;

   &lt;/string-array&gt;

&lt;/resources&gt;
</code></pre><p>上面的string_array_name字符串资源，可以通过如下两种方法调用</p>
<p>XML资源定义中</p>
<pre><code>@[package:]array/string_array_name
</code></pre><p>Java代码中</p>
<pre><code>R.array.string_array_name
</code></pre><h4 id="String-Array用例"><a href="#String-Array用例" class="headerlink" title="String Array用例"></a>String Array用例</h4><p>假设有个String Array资源在/res/values/stringArray.xml中，内容如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;string-array name=&quot;planets_array&quot;&gt;

   &lt;item&gt;Mercury&lt;/item&gt;

   &lt;item&gt;Venus&lt;/item&gt;

   &lt;item&gt;Earth&lt;/item&gt;

   &lt;item&gt;Mars&lt;/item&gt;

   &lt;/string-array&gt;

&lt;/resources&gt;
</code></pre><p>那么在其它资源XML文件中，假设有个下拉列表需要用到上面的字符串数组资源，则可以如下调用</p>
<pre><code>&lt;Spinner android:id=&quot;@+id/spinner1&quot;

   android:layout_width=&quot;fill_parent&quot;

   android:layout_height=&quot;wrap_content&quot;

   android:entries=&quot;@array/planets_array&quot;&gt;

&lt;/Spinner&gt;
</code></pre><p>在Java代码中的调用示例如下</p>
<pre><code>Resources res = getResources();

String[] planets = res.getStringArray(R.array.planets_array);
</code></pre><h3 id="Quantity-Strings语法"><a href="#Quantity-Strings语法" class="headerlink" title="Quantity Strings语法"></a>Quantity Strings语法</h3><pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;plurals name=&quot;plural_name&quot;&gt;

   &lt;item quantity=[&quot;zero&quot; | &quot;one&quot; | &quot;two&quot;| &quot;few&quot; | &quot;many&quot; |&quot;other&quot;]&gt;text_string&lt;/item&gt;

   &lt;/plurals&gt;

&lt;/resources&gt;
</code></pre><p>帮助文档中没有给出XML资源文件中对其的使用方法，也没有明确说不能通过XML调用，我也没有搞明白这个资源，所以暂时只给出Java代码中对上述plural_name资源的调用情况</p>
<pre><code>R.plurals.plural_name
</code></pre><p>其中关于zero、one、two、few和many在帮助文档中有详细的释义，这里就不单独罗列。</p>
<p>Quantity Strings用例</p>
<p>假设有个Quantity Strings资源定义在/res/values/stringQuantity.xml中，内容如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt;

  &lt;plurals name=&quot;numberOfSongsAvailable&quot;&gt;

   &lt;item quantity=&quot;one&quot;&gt;One song found.&lt;/item&gt;

   &lt;item quantity=&quot;other&quot;&gt;%d songs found.&lt;/item&gt;

   &lt;/plurals&gt;

&lt;/resources&gt;
</code></pre><p>由于这个资源，我还不太会用，所以只好照抄帮助文档的使用，至于XML文档中如何使用还不会，在Java代码中使用如下所示</p>
<pre><code>int count = getNumberOfsongsAvailable();

Resources res = getResources();

String songsFound = res.getQuantityString(R.plurals.numberOfSongsAvailable, count, count);
</code></pre><h4 id="String资源的注意项"><a href="#String资源的注意项" class="headerlink" title="String资源的注意项"></a>String资源的注意项</h4><p>Android字符串定义时，假如字符串中含有特殊字符，而又没有使用转义字符，就必须用双引号将字符串完全包住，具体如下所示</p>
<p>//正确使用方法</p>
<pre><code>&lt;string name=&quot;good_example&quot;&gt;&quot;This&apos;ll work&quot;&lt;/string&gt; //没有使用转义字符

&lt;string name=&quot;good_example_2&quot;&gt;This\&apos;ll also work&lt;/string&gt; //使用了转义字符
</code></pre><p>//错误</p>
<pre><code>&lt;string name=&quot;bad_example&quot;&gt;This won&apos;t work!&lt;/string&gt;
</code></pre><p>//错误不可使用html转义字符</p>
<pre><code>&lt;string name=&quot;bad_example_2&quot;&gt;This won&amp;apos;t work!&lt;/string&gt;
</code></pre><p>由上可知，虽然字符串支持HTML标记，但是不支持html的转义字符。另外对于带格式/风格的字符串资源，也是不能在XML代码中调用，只能在Java代码中使用，而且使用过程中有点复杂，需要用htmlEncode解析，然后用String.format()来实现赋值，接着用fromHtml(String)得到格式化后的string。具体帮助文档给出的用例如下</p>
<p>XML资源定义如下：</p>
<pre><code>&lt;resources&gt;

 &lt;string name=&quot;welcome_messages&quot;&gt;Hello, %1$s! You have&amp;lt;b&gt;%2$d new messages&amp;lt;/b&gt;.&lt;/string&gt;

&lt;/resources&gt;
</code></pre><p>Java代码调用如下：</p>
<pre><code>String escapedUsername = TextUtil.htmlEncode(username);

Resources res = getResources();

String text = String.format(res.getString(R.string.welcome_messages), escapedUsername,mailCount);

CharSequence styledText = Html.fromHtml(text);
</code></pre><h3 id="整数常量资源（Integers）"><a href="#整数常量资源（Integers）" class="headerlink" title="整数常量资源（Integers）"></a>整数常量资源（Integers）</h3><p>整数常量在C/C++通常是放在代码里面，android将整型常量、Bool常量和数组常量等等都可以放到XML资源文件中，后面具体介绍这些资源时就不再做展开了。一般整数常量被放置在/res/values/integers.xml中，同样文件名可以随意，但是目录必须固定在/res/values/下</p>
<h4 id="Integer语法"><a href="#Integer语法" class="headerlink" title="Integer语法"></a>Integer语法</h4><pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;integer name=&quot;integer_name&quot;&gt;integer&lt;/integer&gt;

&lt;/resources&gt;
</code></pre><p>上面的integer_name整数常量，可以通过如下两种方法调用</p>
<p>XML资源定义中</p>
<pre><code>@[package:]integer/integer_name
</code></pre><p>Java代码中</p>
<pre><code>R.integer.integer_name
</code></pre><h4 id="Integer用例"><a href="#Integer用例" class="headerlink" title="Integer用例"></a>Integer用例</h4><p>假设整数常量放置在/res/values/integers.xml中，内容如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;integer name=&quot;max_speed&quot;&gt;75&lt;/integer&gt;

   &lt;integer name=&quot;min_speed&quot;&gt;5&lt;/integer&gt;

&lt;/resources&gt;
</code></pre><p>我们在代码中使用的时候，通过以下方式进行调用</p>
<pre><code>Resources res = getResources();

int maxSpeed = res.getInteger(R.integer.max_speed);
</code></pre><h4 id="Integer-Array语法"><a href="#Integer-Array语法" class="headerlink" title="Integer Array语法"></a>Integer Array语法</h4><pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;integer-array name=&quot;integer_array_name&quot;&gt;

   &lt;item&gt;integer&lt;/item&gt;

   &lt;/integer-array&gt;

&lt;/resources&gt;
</code></pre><p>上面定义的integer_array_name可以用如下两种方法调用</p>
<p>XML资源定义中</p>
<pre><code>@[package:]array.integer_array_name
</code></pre><p>Java代码中</p>
<pre><code>R.array.integer_array_name
</code></pre><h4 id="Integer-Array用例"><a href="#Integer-Array用例" class="headerlink" title="Integer Array用例"></a>Integer Array用例</h4><p>假设整数数组放置在/res/values/intergers.xml中，内容如下所示</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;integer-array name=&quot;bits&quot;&gt;

   &lt;item&gt;4&lt;/item&gt;

   &lt;item&gt;8&lt;/item&gt;

   &lt;item&gt;16&lt;/item&gt;

   &lt;item&gt;32&lt;/item&gt;

&lt;/integer-array&gt;

&lt;/resources&gt;
</code></pre><p>该资源在java代码中的调用为</p>
<pre><code>Resources res = getResources();

int[] bits =res.getIntArray(R.array.bits);
</code></pre><h4 id="Typed-Array常量资源"><a href="#Typed-Array常量资源" class="headerlink" title="Typed Array常量资源"></a>Typed Array常量资源</h4><p>Typed Array资源是用于存放多种不同类型资源的数组，本来想将这个资源放后面讲解，但是前面提供了一系列数组案例，就一并将这个数组也提前罗列下吧。该资源一般放置于/res/values/arrays.xml中</p>
<h4 id="Typed-Array语法"><a href="#Typed-Array语法" class="headerlink" title="Typed Array语法"></a>Typed Array语法</h4><pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;array name=&quot;typed_array_name&quot;&gt;

   &lt;item&gt;resource&lt;/item&gt;

   &lt;/array&gt;

&lt;/resources&gt;
</code></pre><p>上面的typed_array_name资源，可以通过如下两种方法调用</p>
<p>XML资源定义中</p>
<pre><code>@[package:]array/typed_array_name
</code></pre><p>Java代码中</p>
<pre><code>R.array.array_name
</code></pre><h4 id="Typed-Array用例"><a href="#Typed-Array用例" class="headerlink" title="Typed Array用例"></a>Typed Array用例</h4><p>假设有两个Typed Array资源定义在/res/values/arrays.xml中，具体如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;array name=&quot;icons&quot;&gt;

   &lt;item&gt;@drawable/home&lt;/item&gt;

   &lt;item&gt;@drawable/settings&lt;/item&gt;

   &lt;item&gt;@drawable/logout&lt;/item&gt;

   &lt;/array&gt;

   &lt;array name=&quot;colors&quot;&gt;

   &lt;item&gt;#FFFF0000&lt;/item&gt;

   &lt;item&gt;#FF00FF00&lt;/item&gt;

   &lt;item&gt;#FF0000FF&lt;/item&gt;

   &lt;/array&gt;

&lt;/resources&gt;
</code></pre><p>该资源通过以下方法在java代码中调用</p>
<pre><code>Resources res = getResources();

TypedArray icons = res.obtainTypedArray(R.array.icons);

Drawable drawable = icons.getDrawable(0);

TypedArray colors = res.obtainTypedArray(R.array.colors);

int color = colors.getColor(0,0);
</code></pre><p>由于每一种类型都是通过不同的API来获取数组中的元素，比如上面用例里面color用int getColor(int index, intdefValue)函数，Drawable用Drawable getDrawable(int index)函数，至于其它相关的类型该调用什么函数来获取具体可以参看android.content.res.TypedArray的源码文件\frameworks\base\core\java\android\content\res\TypedArray.java来获得更多的详情。</p>
<h3 id="布尔常量资源（bool）"><a href="#布尔常量资源（bool）" class="headerlink" title="布尔常量资源（bool）"></a>布尔常量资源（bool）</h3><p>该资源一般定义在/res/values/bools.xml中。</p>
<h4 id="bool语法"><a href="#bool语法" class="headerlink" title="bool语法"></a>bool语法</h4><pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;bool name=&quot;bool_name&quot;&gt;[true| false]&lt;/bool&gt;

&lt;/resources&gt;
</code></pre><p>上面的bool_name布尔常量资源，可以通过如下两种方法调用</p>
<p>XML资源定义中</p>
<pre><code>@[package:]bool/bool_name
</code></pre><p>Java代码中</p>
<pre><code>R.bool.bool_name
</code></pre><h4 id="bool资源用例"><a href="#bool资源用例" class="headerlink" title="bool资源用例"></a>bool资源用例</h4><p>假设有bool常量资源定义在res/values/bools.xml中，内容如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;bool name=&quot;screen_small&quot;&gt;true&lt;/bool&gt;

   &lt;bool name=&quot;adjust_view_bounds&quot;&gt;true&lt;/bool&gt;

&lt;/resources&gt;
</code></pre><p>那么在xml资源中的调用可以如下</p>
<pre><code>&lt;ImageView

   android:layout_height=&quot;fill_parent&quot;

   android:layout_width=&quot;fill_parent&quot;

   android:src=&quot;@drawable/logo&quot;

   android:adjustViewBounds=&quot;@bool/adjust_view_bounds&quot;/&gt;
</code></pre><p>在Java代码中的调用如下</p>
<pre><code>Resources res = getResources();

boolean screenIsSmall = res.getBoolean(R.bool.screen_small);
</code></pre><h3 id="Dimension常量资源"><a href="#Dimension常量资源" class="headerlink" title="Dimension常量资源"></a>Dimension常量资源</h3><p>该资源定义跟屏幕显示相关的一些尺寸常量，一般保存在/res/values/dimen.xml文件中</p>
<p>具体的度量单位有：</p>
<p>px(象素): 屏幕实际的象素，常说的分辨率1024*768pixels，就是横向1024px, 纵向768px，不同设备显示效果相同。</p>
<p>in(英寸): 屏幕的物理尺寸, 每英寸等于2.54厘米。</p>
<p>mm(毫米): 屏幕的物理尺寸。</p>
<p>pt(点): 屏幕的物理尺寸。1/72英寸。</p>
<p>dp/dip: 与密度无关的象素，一种基于屏幕密度的抽象单位。在每英寸160点的显示器上，1dp =1px。但dp和px的比例会随着屏幕密度的变化而改变，不同设备有不同的显示效果。</p>
<p>sp: 与刻度无关的象素，主要用于字体显示best for textsize，作为和文字相关大小单位。</p>
<h4 id="dimension资源定义语法"><a href="#dimension资源定义语法" class="headerlink" title="dimension资源定义语法"></a>dimension资源定义语法</h4><pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;dimen name=&quot;dimension_name&quot;&gt;dimension&lt;/dimen&gt;

&lt;/resources&gt;
</code></pre><h4 id="dimension资源用例"><a href="#dimension资源用例" class="headerlink" title="dimension资源用例"></a>dimension资源用例</h4><p>假设定义了一个dimen资源在res/values/dimens.xml文件中</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;dimen name=&quot;textview_height&quot;&gt;25dp&lt;/dimen&gt;

   &lt;dimen name=&quot;textview_width&quot;&gt;150dp&lt;/dimen&gt;

   &lt;dimen name=&quot;ball_radius&quot;&gt;30dp&lt;/dimen&gt;

   &lt;dimen name=&quot;font_size&quot;&gt;16sp&lt;/dimen&gt;

&lt;/resources&gt;
</code></pre><p>我们可以在XML资源中进行如下调用</p>
<pre><code>&lt;TextView

   android:layout_height=&quot;@dimen/textview_height&quot;

   android:layout_width=&quot;@dimen/textview_width&quot;

   android:textSize=&quot;@dimen/font_size&quot;/&gt;
</code></pre><p>在Java代码中进行如下调用</p>
<pre><code>Resources res = getResources();

float fontSize = res.getDimension(R.dimen.font_size);
</code></pre><h3 id="颜色常量资源（color）"><a href="#颜色常量资源（color）" class="headerlink" title="颜色常量资源（color）"></a>颜色常量资源（color）</h3><p>颜色常量通常被定义在/res/values/colors.xml文件内，同时颜色资源作为一种可绘制的资源，也可以被定义在/res/drawable/文件夹下，调用方式也完全不同，在这里只介绍作为常量的颜色资源。虽然两种定义和调用方式不同，但是颜色的数值表现形式却是一样的，都是形如下面的十六进制格式（后面涉及颜色数值就不再赘述了）</p>
<pre><code>#RGB

#ARGB

#RRGGBB

#AARRGGBB
</code></pre><p>比如#f00表示不透明的12位红色，而#80ff0000表示透明的32位真彩红色</p>
<p>颜色常量语法</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;color name=&quot;color_name&quot;&gt;hex_color&lt;/color&gt;

&lt;/resources&gt;
</code></pre><p>上面的color_name颜色常量可以通过如下两种方法调用</p>
<p>XML资源定义中</p>
<pre><code>@[package:]color/color_name
</code></pre><p>Java代码中</p>
<pre><code>R.color.color_name
</code></pre><h4 id="颜色常量用例"><a href="#颜色常量用例" class="headerlink" title="颜色常量用例"></a>颜色常量用例</h4><p>假设有颜色常量被定义在res/values/colors.xml中</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

  &lt;color name=&quot;opaque_red&quot;&gt;#f00&lt;/color&gt;

  &lt;color name=&quot;translucent_red&quot;&gt;#80ff0000&lt;/color&gt;

&lt;/resources&gt;
</code></pre><p>在XML要使用该常量资源，可以通过如下方法</p>
<pre><code>&lt;TextView

   android:layout_width=&quot;fill_parent&quot;

   android:layout_height=&quot;wrap_content&quot;

   android:textColor=&quot;@color/translucent_red&quot;

   android:text=&quot;Hello&quot;/&gt;
</code></pre><p>在Java代码中如果想使用该资源，则如下调用</p>
<pre><code>Resources res = getResources();

int color = res.getColor(R.color.opaque_red);
</code></pre><p>至此我们将res/values下面定义的资源类型除了风格（Style）和主题（Theme）资源外，全部都介绍过了，由于风格和主题案例需要设计布局（layout）和View等，所以最后再涉及这两类资源的介绍。</p>
<h3 id="状态颜色列表资源（color-state-list）"><a href="#状态颜色列表资源（color-state-list）" class="headerlink" title="状态颜色列表资源（color state list）"></a>状态颜色列表资源（color state list）</h3><p>该资源被放置于/res/color/目录下面，用来定义一个类似Button控件在不同状态下需要呈现不同的颜色。因此这种XML资源文件描述的是跟控件状态相挂钩的颜色状态，具体见下面语法</p>
<h4 id="状态颜色列表资源语法"><a href="#状态颜色列表资源语法" class="headerlink" title="状态颜色列表资源语法"></a>状态颜色列表资源语法</h4><p>假如有个状态颜色列表资源文件res/color/colorstatefile.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;selectorxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;

   &lt;item android:color=&quot;hex_color&quot;

        android:state_pressed=[&quot;true&quot; | &quot;false&quot;]

        android:state_focused=[&quot;true&quot; | &quot;false&quot;]

        android:state_selected=[&quot;true&quot; | &quot;false&quot;]

        android:state_checkable=[&quot;true&quot; | &quot;false&quot;]

        android:state_checked=[&quot;true&quot; | &quot;false&quot;]

        android:state_enabled=[&quot;true&quot; | &quot;false&quot;]

        android:state_window_focused=[&quot;true&quot; | &quot;false&quot;]/&gt;

&lt;/selector&gt;
</code></pre><p>该菜单资源可以通过如下渠道访问</p>
<p>XML资源定义中</p>
<pre><code>@[package:]color/colorstatefile
</code></pre><p>Java代码中</p>
<pre><code>R.color.colorstatefile
</code></pre><p>状态颜色列表资源用例</p>
<p>有一个定义了button状态颜色列表的资源res/color/button_text.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

   &lt;item android:state_pressed=&quot;true&quot;　android:color=&quot;#ffff0000&quot;/&gt; &lt;!-- pressed --&gt;

   &lt;item android:state_focused=&quot;true&quot;　android:color=&quot;#ff0000ff&quot;/&gt; &lt;!-- focused --&gt;

   &lt;item android:color=&quot;#ff000000&quot;/&gt; &lt;!-- default --&gt;

&lt;/selector&gt;
</code></pre><p>则在布局文件中一个Button控件需要使用该状态颜色，就可以通过如下调用</p>
<pre><code>&lt;Button

   android:layout_width=&quot;fill_parent&quot;

   android:layout_height=&quot;wrap_content&quot;

   android:text=&quot;@string/button_text&quot;

   android:textColor=&quot;@color/button_text&quot;/&gt;
</code></pre><h3 id="布局资源（Layout）"><a href="#布局资源（Layout）" class="headerlink" title="布局资源（Layout）"></a>布局资源（Layout）</h3><p>布局资源是放置于/res/layout/下面的用于定义UI界面的XML文件，该资源被用于Activity或者其他UI组件。由于我在学习android之前，没有过Java GUI开发的经验，所以不清楚Java里面的UI设计思想，只知道Android UI类都是基于View和ViewGroup两个类，View类的子类就是“widget”即类似文本框、编辑框等UI控件，ViewGroup的子类就是“Layout”即LinearLayout、RelativeLayout等布局容器类。布局容器类里面可以布局UI控件和其它布局容器对象。在Android中容器就是容器，控件就是控件，只不过容器中除了能放置控件外，也能放置容器，这为我们创建自有复杂的界面提供了条件。</p>
<p>Android提供了多种布局类型，列表如下：</p>
<table>
<thead>
<tr>
<th>布局类型</th>
<th>布局标签</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>线性布局</td>
<td>LinearLayout</td>
<td>按照垂直或水平方向布置控件，每行或列只能放置一个控件</td>
</tr>
<tr>
<td>帧布局</td>
<td>FrameLayout</td>
<td>从屏幕左上角布置控件，不能控制位置，多个控件会叠加放置</td>
</tr>
<tr>
<td>相对布局</td>
<td>RelativeLayout</td>
<td>布局内的view组件元素按照依赖关系相对位置来放置，位置计算只执行一次，因此必须按依赖反向安排组件顺序</td>
</tr>
<tr>
<td>绝对布局</td>
<td>AbsoluteLayout</td>
<td>按照绝对坐标（即x，y）来布局控件（相对用的不多）</td>
</tr>
<tr>
<td>表格布局</td>
<td>TableLayout</td>
<td>按照行列方式布局控件，类似于HTML里的Table</td>
</tr>
<tr>
<td>切换卡</td>
<td>TabWidget</td>
<td>实现标签切换的功能，是一个派生自LinearLayout的布局方式</td>
</tr>
</tbody>
</table>
<p>布局资源的语法</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;ViewGroup xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

   android:id=&quot;@[+][package:]id/resource_name&quot;

   android:layout_height=[&quot;dimension&quot; | &quot;fill_parent&quot; |&quot;wrap_content&quot;]

   android:layout_width=[&quot;dimension&quot; | &quot;fill_parent&quot; |&quot;wrap_content&quot;]

   [ViewGroup-specific attributes] &gt;

   &lt;View android:id=&quot;@[+][package:]id/resource_name&quot;

       android:layout_height=[&quot;dimension&quot; | &quot;fill_parent&quot; |&quot;wrap_content&quot;]

       android:layout_width=[&quot;dimension&quot; | &quot;fill_parent&quot; |&quot;wrap_content&quot;]

       [View-specific attributes] &gt;

       &lt;requestFocus/&gt;

   &lt;/View&gt;

   &lt;ViewGroup &gt;

       &lt;View /&gt;

   &lt;/ViewGroup&gt;

   &lt;include layout=&quot;@layout/layout_resource&quot;/&gt;

&lt;/ViewGroup&gt;
</code></pre><p>上面的布局资源文件名为layoutEx.xml,则可以通过如下两种方法调用</p>
<p>在XML资源定义中</p>
<pre><code>@[package:]layout/layoutEx
</code></pre><p>Java代码中</p>
<pre><code>R.layout.layoutEx
</code></pre><h4 id="布局资源用例"><a href="#布局资源用例" class="headerlink" title="布局资源用例"></a>布局资源用例</h4><p>为了尽可能在在一个例子里面体现更多的布局，为此用例使用如下五个布局文件来关联一个Activity。</p>
<p>第一个布局文件为简单的相对布局，其文件名为right.xml,内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;RelativeLayou tandroid:id=&quot;@+id/right&quot;

       xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

       android:layout_width=&quot;fill_parent&quot;

       android:layout_height=&quot;fill_parent&quot;

       android:padding=&quot;10dip&quot;

       &gt;

       &lt;TextView android:id=&quot;@+id/right_view1&quot;

              android:background=&quot;@drawable/yellow&quot;

              android:layout_width=&quot;fill_parent&quot;

              android:layout_height=&quot;wrap_content&quot;

              android:text=&quot;第二组第1项&quot; /&gt;

       &lt;TextView android:id=&quot;@+id/right_view2&quot;

              android:background=&quot;@drawable/blue&quot;

              android:layout_width=&quot;fill_parent&quot;

              android:layout_height=&quot;wrap_content&quot;

              android:layout_below=&quot;@id/right_view1&quot;

              android:text=&quot;第二组第二项&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>第二个布局文件为水平线性布局内嵌入两个布局文件，文件名为first.xml,内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;LinearLayout

 xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

 android:layout_width=&quot;fill_parent&quot;

 android:layout_height=&quot;wrap_content&quot;

  android:orientation=&quot;horizontal&quot;&gt;

  &lt;RelativeLayout

       android:id=&quot;@+id/left_view&quot;

       xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

       android:layout_width=&quot;100dip&quot;

       android:layout_height=&quot;100dip&quot;

       android:padding=&quot;10dip&quot;      &gt;



       &lt;TextViewandroid:id=&quot;@+id/Left_view1&quot;

              android:background=&quot;@drawable/blue&quot;

              android:layout_width=&quot;fill_parent&quot;

              android:layout_height=&quot;50px&quot;

              android:text=&quot;第1组第1项&quot; /&gt;

       &lt;TextViewandroid:id=&quot;@+id/Left_view2&quot;

              android:background=&quot;@drawable/yellow&quot;

              android:layout_width=&quot;fill_parent&quot;

              android:layout_height=&quot;50px&quot;

              android:layout_below=&quot;@id/Left_view1&quot;

              android:text=&quot;第1组第2项&quot; /&gt;

       &lt;/RelativeLayout&gt;



       &lt;include  layout = &quot;@layout/right&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>第三个布局文件为表格布局文件，文件名为table.xml，内容如下：</p>
<pre><code>&lt;TableLayout　xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

       android:layout_width=&quot;fill_parent&quot;android:layout_height=&quot;wrap_content&quot;

       android:clickable=&quot;true&quot;android:stretchColumns=&quot;1&quot;&gt;

       &lt;TableRow&gt;

              &lt;TextViewandroid:text=&quot;用户名:&quot; android:textStyle=&quot;bold&quot;

                     android:gravity=&quot;right&quot;android:padding=&quot;3dip&quot; /&gt;


              &lt;EditTextandroid:id=&quot;@+id/username&quot; android:padding=&quot;3dip&quot;

                     android:scrollHorizontally=&quot;true&quot;/&gt;

       &lt;/TableRow&gt;

       &lt;TableRow&gt;

              &lt;TextViewandroid:text=&quot;登录密码:&quot; android:textStyle=&quot;bold&quot;

                     android:gravity=&quot;right&quot;android:padding=&quot;3dip&quot; /&gt;


              &lt;EditTextandroid:id=&quot;@+id/password&quot; android:password=&quot;true&quot;

                     android:padding=&quot;3dip&quot;android:scrollHorizontally=&quot;true&quot; /&gt;

       &lt;/TableRow&gt;

       &lt;TableRowandroid:gravity=&quot;right&quot;&gt;


              &lt;Buttonandroid:id=&quot;@+id/cancel&quot;

                     android:text=&quot;取消&quot; /&gt;

              &lt;Buttonandroid:id=&quot;@+id/login&quot;

                     android:text=&quot;登录&quot; /&gt;

       &lt;/TableRow&gt;

&lt;/TableLayout&gt;
</code></pre><p>第四个布局文件为帧布局，文件名为frame.xml,内容如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;FrameLayout　android:id=&quot;@+id/left&quot;

       xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

       android:layout_width=&quot;fill_parent&quot;

       android:layout_height=&quot;wrap_content&quot;&gt;


       &lt;ImageViewandroid:id=&quot;@+id/photo&quot; android:src=&quot;@drawable/bg&quot;

              android:layout_width=&quot;wrap_content&quot;

              android:layout_height=&quot;wrap_content&quot;  /&gt;

&lt;/FrameLayout&gt;
</code></pre><p>第五个布局文件为垂直线性布局文件，文件名为main.xml,内容如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;LinearLayout　xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

       android:orientation=&quot;vertical&quot;android:layout_width=&quot;fill_parent&quot;

       android:layout_height=&quot;fill_parent&quot;&gt;

       &lt;include  layout = &quot;@layout/first&quot; /&gt;

       &lt;include  layout = &quot;@layout/table&quot; /&gt;

       &lt;include  layout = &quot;@layout/frame&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>最后在主Activity中的</p>
<pre><code>public class ActivityMain extends Activity{

   /** Called when the activity is first created. */

   @Override

   public void onCreate(Bundle savedInstanceState) {

              super.onCreate(savedInstanceState);     

              setContentView(R.layout.main);

       }

}
</code></pre><h3 id="菜单资源（menu）"><a href="#菜单资源（menu）" class="headerlink" title="菜单资源（menu）"></a>菜单资源（menu）</h3><p>菜单资源位于/res/menu/目录下，相较于其它资源而言，菜单在android中目前我看到的代码，很多时候是用代码直接生成的，直接用资源的比较少一点。在Android中，有三类菜单：选项菜单、上下文菜单和子菜单。从创建菜单的步骤来看，选项菜单和子菜单的创建都遵循下列步骤：</p>
<pre><code>a、覆盖Activity的OnCreateOptionsMenu（Menu menu）方法，在其中添加弹出菜单的代码

b、覆盖Activity的OnOptionsItemSelected（）方法，在其中添加选中不同菜单项后的处理流程
</code></pre><p>如果是通过资源来创建菜单，那么两者代码没有区别，只是资源编辑考虑了树形结构而已，假如代码创建，那么前者使用Menu的add方法，后者通过SubMenu的Add方法。</p>
<p>上下文菜单的创建步骤为：</p>
<pre><code>a、覆盖Activity的OnCreateContextMenu()方法，在其中添加弹出菜单的代码

b、覆盖Activity的OnContextItemSelected（）方法，在其中添加选中不同菜单项后的处理流程

c、一般在Activity的OnCreate函数中调用registerForContextMenu()方法，为视图注册上下文菜单
</code></pre><h3 id="菜单资源语法"><a href="#菜单资源语法" class="headerlink" title="菜单资源语法"></a>菜单资源语法</h3><p>假如有个菜单资源文件res/menu/menufile.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;menuxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

   &lt;item android:id=&quot;@[+][package:]id/resource_name&quot;

         android:title=&quot;string&quot;

         android:titleCondensed=&quot;string&quot;

         android:icon=&quot;@[package:]drawable/drawable_resource_name&quot;

         android:onClick=&quot;method name&quot;

         android:showAsAction=[&quot;ifRoom&quot; | &quot;never&quot; |&quot;withText&quot; | &quot;always&quot;]

         android:actionLayout=&quot;@[package:]layout/layout_resource_name&quot;

         android:actionViewClass=&quot;class name&quot;

         android:alphabeticShortcut=&quot;string&quot;

         android:numericShortcut=&quot;string&quot;

         android:checkable=[&quot;true&quot; | &quot;false&quot;]

         android:visible=[&quot;true&quot; | &quot;false&quot;]

         android:enabled=[&quot;true&quot; | &quot;false&quot;]

         android:menuCategory=[&quot;Container&quot; | &quot;system&quot; |&quot;secondary&quot; | &quot;alternative&quot;]

         android:orderInCategory=&quot;integer&quot; /&gt;

  &lt;group android:id=&quot;@[+][package:]id/resource name&quot;

          android:checkableBehavior=[&quot;none&quot; | &quot;all&quot; |&quot;single&quot;]

          android:visible=[&quot;true&quot; | &quot;false&quot;]

          android:enabled=[&quot;true&quot; |&quot;false&quot;]

          android:menuCategory=[&quot;container&quot; | &quot;system&quot; |&quot;secondary&quot; | &quot;alternative&quot;]

          android:orderInCategory=&quot;integer&quot; &gt;

       &lt;item /&gt;

   &lt;/group&gt;

   &lt;item &gt;

       &lt;menu&gt;

         &lt;item /&gt;

        &lt;/menu&gt;

   &lt;/item&gt;

&lt;/menu&gt;
</code></pre><p>该菜单资源可以通过如下渠道访问</p>
<p>XML资源定义中</p>
<pre><code>@[package:]menu/menufile
</code></pre><p>Java代码中</p>
<pre><code>R.menu.menufile
</code></pre><p>由上述语法结构，可知<code>&lt;menu&gt;</code>根元素，在<code>&lt;menu&gt;</code>根元素里面会嵌套<code>&lt;item&gt;</code>和<code>&lt;group&gt;</code>子元素，<code>&lt;item&gt;</code>元素中也可嵌套<code>&lt;menu&gt;</code>形成子菜单。</p>
<p>下面对语法中的标签做下简单分析</p>
<p><code>&lt;menu&gt;</code>标签是根元素，他没有属性，可包含<code>&lt;item&gt;</code>和<code>&lt;group&gt;</code>子元素。</p>
<p><code>&lt;group&gt;</code>标签表示一个菜单组，相同的菜单组可以一起设置其属性，例如visible、enabled和checkable等属性。具体罗列说明如下：</p>
<pre><code>id：唯一标示该菜单组的引用id

menuCategory：对菜单进行分类，定义菜单的优先级，有效值为container、system、secondary和alternative

orderInCategory：一个分类排序整数

checkableBehavior：选择行为，单选、多选还是其他。有效值为none、all和single

visible：是否可见，true或者false

enabled：是否可用，true或者false
</code></pre><p><code>&lt;item&gt;</code>标签表示具体的菜单项，包含在<code>&lt;menu&gt;</code>或<code>&lt;group&gt;</code>中。<code>&lt;item&gt;</code>元素的属性说明如下：</p>
<pre><code>id：唯一标示菜单的ID引用，选中该菜单项后，MenuItem::getItemId()返回的就是这个ID值

menuCategory：菜单分类

orderInCategory：分类排序

title：菜单标题字符串

titleCondensed：浓缩标题，适合标题太长的时候使用

icon：菜单的图标

alphabeticShortcut：字符快捷键

numericShortcut：数字快捷键

checkable：是否可选

checked：是否已经被选

visible：是否可见

enabled：是否可用
</code></pre><h4 id="菜单资源用例"><a href="#菜单资源用例" class="headerlink" title="菜单资源用例"></a>菜单资源用例</h4><p>这里用例分别为两个TextView弹出两个上下文菜单，所以使用了两个menu资源，具体实例如下。</p>
<p>示例程序的布局res/layout/main.xml，内容为</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;LinearLayoutxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

   android:orientation=&quot;vertical&quot;

   android:layout_width=&quot;fill_parent&quot;

   android:layout_height=&quot;fill_parent&quot;

   &gt;

&lt;TextView

       android:id=&quot;@+id/textView1&quot;

   android:layout_width=&quot;fill_parent&quot;

   android:layout_height=&quot;wrap_content&quot;

    android:text=&quot;File Menu&quot; /&gt;

&lt;TextView     

       android:id=&quot;@+id/textView2&quot;

       android:layout_width=&quot;fill_parent&quot;

       android:layout_height=&quot;wrap_content&quot;

       android:text=&quot;EditMenu&quot; &gt;&lt;/TextView&gt;

&lt;/LinearLayout&gt;
</code></pre><p>两份菜单资源分别为</p>
<blockquote>
<p>//res/menu/view1menu.xml</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;menu　xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

 android:title=&quot;File&quot;&gt;

    &lt;item

       android:id=&quot;@+id/newFile&quot;

       android:title=&quot;New&quot;

       android:alphabeticShortcut=&quot;n&quot;/&gt;

   &lt;item

       android:id=&quot;@+id/openFile&quot;

       android:title=&quot;Open&quot;

       android:alphabeticShortcut=&quot;o&quot;/&gt;

   &lt;item

       android:id=&quot;@+id/saveFile&quot;

       android:title=&quot;Save&quot;

       android:alphabeticShortcut=&quot;s&quot;/&gt;

&lt;/menu&gt;
</code></pre><blockquote>
<p>//res/menu/view2menu.xml</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;menu　xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

   &lt;item

        android:id=&quot;@+id/cut&quot;

        android:title=&quot;Cut&quot; /&gt;

   &lt;item

        android:id=&quot;@+id/copy&quot;

        android:title=&quot;Copy&quot;/&gt;

   &lt;item

        android:id=&quot;@+id/past&quot;

        android:title=&quot;Past&quot;/&gt;

&lt;/menu&gt;
</code></pre><p>程序在Activity中的代码清单如下</p>
<pre><code>public class MenuDemoActivity extends　Activity

{    

   private TextView view1;

   private TextView view2;



   /** Called when the activity is first created. */

   @Override

   public void onCreate(Bundle savedInstanceState) {

        super.onCreate(savedInstanceState);

        setContentView(R.layout.main);

        view1 = (TextView) findViewById(R.id.textView1);

        view2 = (TextView) findViewById(R.id.textView2);

        registerForContextMenu(view1);

        registerForContextMenu(view2);

   }


   @Override

   public void onCreateContextMenu(ContextMenumenu, View v, ContextMenu.ContextMenuInfo menuInfo)

   {

           MenuInflater inflater =getMenuInflater();

           switch(v.getId())

           {

           case R.id.textView1:

                  menu.setHeaderTitle(&quot;File&quot;);

                  inflater.inflate(R.menu.view1menu,menu);            

                  break;

           case R.id.textView2:

                  inflater.inflate(R.menu.view2menu,menu);

                  menu.setHeaderTitle(&quot;Edit&quot;);

                  break;

           }

   }



   @Override

   public boolean onContextItemSelected(MenuItemitem)

   {

           super.onContextItemSelected(item);

           switch(item.getItemId())

           {

           case R.id.newFile:

                  break;

           }

           return false;

   }

}
</code></pre><h4 id="为ListView注册上下文菜单"><a href="#为ListView注册上下文菜单" class="headerlink" title="为ListView注册上下文菜单"></a>为ListView注册上下文菜单</h4><p>To get the item from the ListView item selected refer to ContextMenuInfo object (see last implemented method below). Full solution as follows:<br>1) register ListView for context menu in ListActivity class</p>
<pre><code>@Override public void onCreate(Bundle savedInstanceState){super.onCreate(savedInstanceState);// ...
    getListView().setAdapter(mAdapter);
    registerForContextMenu(getListView());
}
</code></pre><p>a) if you have complex View on your list you might need to enable long click on each list view in Adapter class</p>
<pre><code>@Override public View getView(int position,View convertView,ViewGroup parent){
    View view = convertView;
    if(view ==null){
        RelativeLayout layout =(RelativeLayout)LayoutInflater.from(mContext).inflate(R.layout.li  st_item, parent,false);
        itemLayout = layout;
        itemLayout.setLongClickable(true);}// 
        ...
        return view;
}
</code></pre><p>2) implement onCreateContextMenu() and onContextItemSelected() in ListActivity class</p>
<pre><code>@Override public void onCreateContextMenu(ContextMenu menu,View v,ContextMenuInfo menuInfo){
        super.onCreateContextMenu(menu, v, menuInfo);
        AdapterContextMenuInfo info =(AdapterContextMenuInfo) menuInfo;
        String title =((MyItem) mAdapter.getItem(info.position)).getTitle();
        menu.setHeaderTitle(title);
        menu.add(Menu.NONE, MENU_CONTEXT_DELETE_ID,Menu.NONE, DELETE_TEXT);
}


@Override public boolean onContextItemSelected(MenuItem item){
    switch(item.getItemId()){
        case MENU_CONTEXT_DELETE_ID:
            AdapterContextMenuInfo info =(AdapterContextMenuInfo) item.getMenuInfo();
            Log.d(TAG,&quot;removing item pos=&quot;+ info.position);
            mAdapter.remove(info.position);
            return true;
        default:
            return super.onContextItemSelected(item);
   }
}
</code></pre><h4 id="代码中创建Menu"><a href="#代码中创建Menu" class="headerlink" title="代码中创建Menu"></a>代码中创建Menu</h4><p>在用户第一次按下Menu键的使用，将触发onCreateOptionsMenu()，我们将在此创建我们的菜单</p>
<pre><code>public boolean onCreateOptionsMenu(Menu menu) {
    /*第一个参数是groupId，如果不需要可以设置为Menu.NONE。
    * 第二个参数就是item的ID，我们可以通过menu.findItem(id)来获取具体的item 
    * 第三个参数是item的顺序，一般可采用Menu.NONE，具体看本文最后MenuInflater的部分
    * 第四个参数是显示的内容，可以是String，或者是引用Strings.xml的ID*/
    menu.add(Menu.NONE,ONE_ID,Menu.NONE,&quot;1 Pixel&quot;);
    menu.add(Menu.NONE, TWO_ID, Menu.NONE, &quot;2 Pixels&quot;);
    menu.add(Menu.NONE, EIGHT_ID, Menu.NONE, &quot;8 Pixels&quot;);
    menu.add(Menu.NONE, SIXTEEN_ID, Menu.NONE, &quot;16 Pixels&quot;);
    menu.add(Menu.NONE, TWENTY_FOUR_ID, Menu.NONE, &quot;24 Pixels&quot;);
    menu.add(Menu.NONE, THIRTY_TWO_ID, Menu.NONE, &quot;32 Pixels&quot;);
    menu.add(Menu.NONE, FORTY_ID, Menu.NONE, &quot;40 Pixels&quot;);
    return super.onCreateOptionsMenu(menu);
}
</code></pre><p>实际使用过的代码</p>
<pre><code>menu.add(Menu.NONE, R.id.delete_this_label,Menu.NONE, R.string.delete_this_label);
</code></pre><h3 id="动画资源（animation）"><a href="#动画资源（animation）" class="headerlink" title="动画资源（animation）"></a>动画资源（animation）</h3><p>Android 3.0 SDK发布后，动画提供了三种实现方案：</p>
<p>逐帧动画类型（frame by frame Animation），这种动画的效果跟电影和gif动画一样的原理一样，即用一帧一帧的图片设定显示时间和顺序，进行顺序播放，调用资源的相关源码位于\frameworks\base\graphics\java\android\graphics\drawable\AnimationDrawable.java中，自然具体类就是android.graphics.drawable.animationdrawable；</p>
<p>补间动画（Tween Animation），这种动画是针对view控件进行移动、缩放、旋转和Alpha渐变等操作来实现动画效果。调用资源的相关源码不像逐帧动画那么简单，具体有个源码包位于\frameworks\base\core\java\android\view\animation（也即android.view.animation包）；</p>
<p>属性动画（Property Animation），这种动画是Android 3.0新引进的动画框架，目前找到的资料比较少，不知道中文译名用什么好，暂时称其为属性动画吧。而且源码也没有公开，只是知道使用源码包为android.animation。不过通过SDK自带的APIDemo程序提供的案例可以看出，实现的效果与插间动画类似，只不过不用通过View控件来实现。</p>
<h4 id="逐帧动画语法"><a href="#逐帧动画语法" class="headerlink" title="逐帧动画语法"></a>逐帧动画语法</h4><p>逐帧动画的资源定义文件可以放置在/res/drawable/下面，也可以放置在/res/anim/文件夹下，由于所放置的位置不同，导致调用时也是需要作出区分的。如下语法文件frameanim.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

   android:oneshot=[&quot;true&quot; | &quot;false&quot;] &gt;

   &lt;item

       android:drawable=&quot;@[package:]drawable/drawable_resource_name&quot;

       android:duration=&quot;integer&quot; /&gt;

&lt;/animation-list&gt;
</code></pre><p>如果该文件被放置于res/drawable或res/anim，则调用时的情况分别如下</p>
<p>在Xml中的调用</p>
<pre><code>@[package:]drawable/frameanim   或@[package:]anim/frameanim
</code></pre><p>在Java代码中的调用则如下</p>
<pre><code>R.drawable.frameanim  或 R.anim.frameanim
</code></pre><h4 id="逐帧动画用例"><a href="#逐帧动画用例" class="headerlink" title="逐帧动画用例"></a>逐帧动画用例</h4><p>个人还是比较倾向于将逐帧动画资源放置在res/drawable下面，摘录用例如下</p>
<p>在res/drawable/frameanimation.xml中定义了如下动画资源</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

   android:oneshot=&quot;false&quot;&gt;


        &lt;item android:drawable=&quot;@drawable/a1&quot;android:duration=&quot;500&quot; /&gt;

        &lt;itemandroid:drawable=&quot;@drawable/a2&quot; android:duration=&quot;500&quot;/&gt;

        &lt;item android:drawable=&quot;@drawable/a3&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a4&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a5&quot; android:duration=&quot;500&quot;/&gt;

        &lt;item android:drawable=&quot;@drawable/a6&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a7&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a8&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a9&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a10&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a11&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a12&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a13&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a14&quot;android:duration=&quot;500&quot; /&gt;

        &lt;item android:drawable=&quot;@drawable/a15&quot;android:duration=&quot;500&quot; /&gt;     

&lt;/animation-list&gt;
</code></pre><p>由于drawable类动画必须借助view类对象，简单点的就是imageview控件，为此我们将上述资源用于如下布局文件文件中</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;   

&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  

   android:orientation=&quot;vertical&quot;    

   android:layout_width=&quot;fill_parent&quot;  

   android:layout_height=&quot;fill_parent&quot;&gt;   

   &lt;ImageView    

      android:id=&quot;@+id/animation_view&quot;  

      android:layout_width=&quot;fill_parent&quot;    

      android:layout_height=&quot;wrap_content&quot;  

      android:src=&quot;@drawable/frameanimation&quot; /&gt;   

   &lt;Button    

      android:id=&quot;@+id/animation_btn&quot;    

      android:layout_width=&quot;fill_parent&quot;  

      android:layout_height=&quot;wrap_content&quot;    

      android:text=&quot;@string/start_animation&quot; /&gt;   

   &lt;Button    

      android:id=&quot;@+id/one_shot_btn&quot;    

      android:layout_width=&quot;fill_parent&quot;  

      android:layout_height=&quot;wrap_content&quot;    

      android:text=&quot;@string/play_once&quot; /&gt;   

&lt;/LinearLayout&gt; 
</code></pre><p>然，在代码中就可以直接进行如下代码编辑</p>
<pre><code>public class AnimActivity extends Activity

{   

   /** Called when the activity is first created. */  

   AnimationDrawable mAd;   

   Button mPlayBtn;   

   Button mOneShotBtn;   

   boolean mIsOneShot;   



   @Override  

   public void onCreate(Bundle savedInstanceState)

   {   

      super.onCreate(savedInstanceState);   

      setContentView(R.layout.main);   



      ImageView iv = (ImageView) findViewById(R.id.animation_view);   

      mAd = (AnimationDrawable) iv.getDrawable();   



      mPlayBtn = (Button) findViewById(R.id.animation_btn);   

      mPlayBtn.setOnClickListener(new OnClickListener()

      {   

          @Override  

          public void onClick(View view)

         {   

              startAnimation();   

          }   

      });   



      mOneShotBtn = (Button) findViewById(R.id.one_shot_btn);   

      mOneShotBtn.setOnClickListener(new OnClickListener()

     {   

          @Override  

          public void onClick(View view)

          {   

              if (mIsOneShot)

              {   

                  mOneShotBtn.setText(&quot;PlayOnce&quot;);   

              }

              else

              {   

                 mOneShotBtn.setText(&quot;Play Repeatly&quot;);   

              }   

              mAd.setOneShot(!mIsOneShot);   

              mIsOneShot = !mIsOneShot;    

          }   

      });   



   }   



   /**  

    * 通过AnimationDrawable的start函数播放动画，  

    * stop函数停止动画播放，  

    * isRunning来判断动画是否正在播放。  

    */  

   public void startAnimation() {   

      if (mAd.isRunning()) {   

          mAd.stop();   

      } else {   

          mAd.stop();   

          mAd.start();   

      }   

   }   

} 
</code></pre><h4 id="补间动画语法"><a href="#补间动画语法" class="headerlink" title="补间动画语法"></a>补间动画语法</h4><p>该类资源定义必须在res/anim目录下。补间动画源自flash动画制作，即给出两个关键帧在中间需要做“补间动画”，才能实现图画的运动；插入补间动画后两个关键帧之间的插补帧是由计算机自动运算而得到的。所以相对补间动画，需要的参数有起始帧、结束帧、变化方式和变化速度，Android SDK提供了四类基本变化方法，具体详见如下语法</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

   android:interpolator=&quot;@[package:]anim/interpolator_resource&quot;

   android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt;

   &lt;alpha

       android:fromAlpha=&quot;float&quot;

       android:toAlpha=&quot;float&quot;

       android:duration=&quot;int&quot; /&gt;

   &lt;scale

       android:fromXScale=&quot;float&quot;

       android:toXScale=&quot;float&quot;

       android:fromYScale=&quot;float&quot;

       android:toYScale=&quot;float&quot;

        android:pivotX=&quot;float&quot;

       android:pivotY=&quot;float&quot; /&gt;

   &lt;translate

       android:fromXDelta=&quot;float&quot;

       android:toXDelta=&quot;float&quot;

       android:fromYDelta=&quot;float&quot;

       android:toYDelta=&quot;float&quot; /&gt;

   &lt;rotate

       android:fromDegrees=&quot;float&quot;

       android:toDegrees=&quot;float&quot;

       android:pivotX=&quot;float&quot;

       android:pivotY=&quot;float&quot; /&gt;

   &lt;set&gt;

       ...

   &lt;/set&gt;

&lt;/set&gt;
</code></pre><p>以上四种变化方法，分别对应四个变化函数</p>
<pre><code>AlphaAnimation(float fromAlpha, float toAlpha)
</code></pre><p>功能：构建一个透明度渐变动画</p>
<p>参数：fromAlpha为动画起始帧的透明度，toAlpha为动画结束帧的透明度（0.0表示完全透明，1.0表完全不透明）</p>
<pre><code>RotateAnimation(float fromDegrees, float toDegrees, int pivotXType,float pivotXValue, int pivotYType, float pivotYValue)
</code></pre><p>功能：构建一个旋转画面的动画</p>
<p>参数：fromDegrees为开始帧的角度，toDegrees是结束帧的角度（负的度数表示逆时针角度，比如fromDegrees =180，toDegrees= -360则开始帧位置是图像绕圆心顺时针转180度，逆时针旋转至540度）；后面四个参数决定了旋转的圆心位置，pivotXType和pivotYType确定了圆心位置的类型，pivotXValue和pivotYValue是具体的位置坐标系数，类型参数有Animation.ABSOLUTE,Animation.RELATIVE_TO_SELF和Animation.RELATIVE_TO_PARENT三种，当absolute时表示绝对坐标，此时pivotXValue和pivotYValue就是屏幕上的绝对像素坐标位置，即（android:pivotX=”20” android:pivotY=”20” ）表示圆心为屏幕（20,20）这个点；relative_to_self表示相对自身，即假设自身为（0,0，20,20）的矩形控件，那么（android:pivotX=”50%” android:pivotY=”50%”）表示圆心的位置为控件的中心，即绝对坐标（10,10）；relative_to_parent显然就是先对父窗口的比例圆心，用（android:pivotX=”50%p”android:pivotY=”50%p”）来表示绕父窗口中心点旋转。</p>
<pre><code>ScaleAnimation(float fromX, float toX, float fromY, float toY, intpivotXType, float pivotXValue, int pivotYType, float pivotYValue)
</code></pre><p>功能：构建一个缩放动画</p>
<p>参数：fromX，fromY，toX，toY分别表示起始帧和结束帧相对于源图像在X和Y方向的伸缩大小，0.0表示缩小到无，小于1.0表示缩小，1.0表示正常大小，大于1.0表示放大；后面四个参数与旋转的参数等同，表示缩放是的参考点。</p>
<pre><code>TranslateAnimation(int fromXType, float fromXValue, int toXType,float toXValue, int fromYType, float fromYValue, int toYType, float toYValue)
</code></pre><p>功能：构建一个位移动画</p>
<p>参数：前面四个参数确定一个起始坐标，后面四个参数确定一个结束坐标，这些坐标位置是采用了类似旋转圆心的算法。</p>
<p>上面语法中没有涉及到android:interpolator，这个就是变化速度，目前android系统提供了如下一些速度变化器。</p>
<table>
<thead>
<tr>
<th>Interpolator class</th>
<th>Resource ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>AccelerateDecelerateInterpolator</td>
<td>@android:anim/accelerate_decelerate_interpolator</td>
</tr>
<tr>
<td>AccelerateInterpolator</td>
<td>@android:anim/accelerate_interpolator</td>
</tr>
<tr>
<td>AnticipateInterpolator</td>
<td>@android:anim/anticipate_interpolator</td>
</tr>
<tr>
<td>AnticipateOvershootInterpolator</td>
<td>@android:anim/anticipate_overshoot_interpolator</td>
</tr>
<tr>
<td>BounceInterpolator</td>
<td>@android:anim/bounce_interpolator</td>
</tr>
<tr>
<td>CycleInterpolator</td>
<td>@android:anim/cycle_interpolator</td>
</tr>
<tr>
<td>DecelerateInterpolator</td>
<td>@android:anim/decelerate_interpolator</td>
</tr>
<tr>
<td>LinearInterpolator</td>
<td>@android:anim/linear_interpolator</td>
</tr>
<tr>
<td>OvershootInterpolator</td>
<td>@android:anim/overshoot_interpolator</td>
</tr>
</tbody>
</table>
<p>详情还是参考android.view.animation包中相关的源码吧。</p>
<p>下面再说下补间动画的创建步骤（下面步骤考虑到复杂变化，所以引入了set，如果单一变化可以不用set对象）</p>
<pre><code>1.创建一个AnimationSet对象。

2.根据需要创建相应的Animation对象

3.根据软件动画的需求，为Animation对象设置相应的数据。

4.将Animation对象添加到AnimationSet对象当中。

5.使用控件对象开始执行AnimationSet
</code></pre><h4 id="补间动画用例"><a href="#补间动画用例" class="headerlink" title="补间动画用例"></a>补间动画用例</h4><p>补间动画的示例源码变化较多，在这里就不详细罗列，大家可以参看Android开发揭秘案例</p>
<p>也可以参看如下链接：</p>
<p><a href="http://blog.sina.com.cn/s/blog_78c913e30100w6cd.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_78c913e30100w6cd.html</a></p>
<p><a href="http://www.ophonesdn.com/article/show/185" target="_blank" rel="external">http://www.ophonesdn.com/article/show/185</a></p>
<p><a href="http://www.ophonesdn.com/article/show/186" target="_blank" rel="external">http://www.ophonesdn.com/article/show/186</a></p>
<p><a href="http://www.ophonesdn.com/article/show/322" target="_blank" rel="external">http://www.ophonesdn.com/article/show/322</a></p>
<h4 id="属性动画语法"><a href="#属性动画语法" class="headerlink" title="属性动画语法"></a>属性动画语法</h4><p>属性动画一般要求资源定义文件位于/res/animator/下面，但是如果将其放置在res/anim下面也是允许的。比如在res/anim/propertyanimations.xml文件中进行类似如下定义</p>
<pre><code>&lt;set

 android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt;

   &lt;objectAnimator android:propertyName=&quot;string&quot;

       android:duration=&quot;int&quot;

       android:valueFrom=&quot;float | int | color&quot;

       android:valueTo=&quot;float | int | color&quot;

       android:startOffset=&quot;int&quot;

       android:repeatCount=&quot;int&quot;

       android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]

       android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt;

   &lt;animator

       android:duration=&quot;int&quot;

       android:valueFrom=&quot;float | int | color&quot;

       android:valueTo=&quot;float | int | color&quot;

       android:startOffset=&quot;int&quot;

       android:repeatCount=&quot;int&quot;

       android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]

       android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]/&gt;

   &lt;set&gt;

       ...

   &lt;/set&gt;

&lt;/set&gt;
</code></pre><p>那么就可以在XML中对其进行如下调用</p>
<pre><code>@[package:]anim/propertyanimations
</code></pre><p>在Java代码中可以对其进行如下调用</p>
<pre><code>R.anim.propertyanimations
</code></pre><h4 id="属性动画用例"><a href="#属性动画用例" class="headerlink" title="属性动画用例"></a>属性动画用例</h4><p>具体用例还是参看android SDK3.0 自带的例子程序API demo中的ApiDemos\src\com\example\android\apis\animation\AnimationLoading.java等案例。</p>
<h3 id="可绘制资源（Drawable资源）"><a href="#可绘制资源（Drawable资源）" class="headerlink" title="可绘制资源（Drawable资源）"></a>可绘制资源（Drawable资源）</h3><p>其实上面用到的逐帧动画，就是可绘制资源的中的一种，绘制资源涉及的资源类型比较多，详细列表说明如下</p>
<table>
<thead>
<tr>
<th>资源类型</th>
<th>资源描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap File</td>
<td>图像文件（ .png 、 .jpg 或 .gif ）</td>
</tr>
<tr>
<td>XML Bitmap</td>
<td>为图像文件增加了描述的XML文件（当然描述跟下面罗列的类型不一样）</td>
</tr>
<tr>
<td>Nine-Patch File</td>
<td>一种可基于Content伸缩的PNG文件（.9.png）</td>
</tr>
<tr>
<td>Layer List</td>
<td>定义了一组按顺序绘制可绘制资源的XML文件</td>
</tr>
<tr>
<td>State List</td>
<td>定义了因不同状态而调用不同图像文件的XML文件</td>
</tr>
<tr>
<td>Level List</td>
<td>定义了不同level图片的XML文件，主要用于类似电量、信号等类似情况</td>
</tr>
<tr>
<td>Transition Drawable</td>
<td>定义了两张图片，让其在规定时间内渐变的XML文件</td>
</tr>
<tr>
<td>Inset Drawable</td>
<td>定义一个内嵌图片的XML（可设置四边距），通常给控件做内插背景用</td>
</tr>
<tr>
<td>Clip Drawable</td>
<td>定义一个图片的XML，该图片资源可以根据level等级来剪取需要显示比例内容</td>
</tr>
<tr>
<td>Scale Drawable</td>
<td>定义一个图片的XML，该图片可以根据level等级进行缩放</td>
</tr>
<tr>
<td>Shape Drawable</td>
<td>定义了绘制颜色和渐变的几何形状的XML文件</td>
</tr>
<tr>
<td>Animation Drawable</td>
<td>定义了逐帧动画的XML文件，在上面动画资源中讲解过了</td>
</tr>
<tr>
<td>Color</td>
<td>定义了绘制颜色值的XML，感觉同values内的color一样，只是调用形式有点区别</td>
</tr>
</tbody>
</table>
<p>综合来说，可绘制资源可以大致分为三类：</p>
<p><strong>直接图片资源类</strong> 该类都是图像文件，有Bitmap File和Nine-Patch File，而且图像文件，API文档虽然说.png 、 .jpg 或 .gif 格式都支持，但是也提议 .png （最佳）、 .jpg （可接受）、 .gif （不要）的原则，另外考虑到aapt编译资源时会考虑优化，所以如果图像要绝对保真，还是将图像文件放置在res/raw目录下的比较好；</p>
<p><strong>图像描述类</strong> 该类涉及对一个或多个图像文件进行添加配置和重新定义，都是XML资源描述文件，其中包括Layer List、State List、Level List、Transition Drawable、Inset Drawable、Clip Drawable、Scale Drawable、Animation Drawable这几类，通常这些资源或被用作控件view的填充图像，或被用作控件view的背景；</p>
<p><strong>直接绘图类</strong> 该类也是资源定义XML文件，主要是Shape Drawable类和color类。</p>
<p>由于资源细分类型众多，对于直接图片类资源就不做展开介绍了，对于图像描述类资源，只选取了Clip Drawable和Scale Drawable两类的用例来简单说明下，对于直绘类则采用了Shape Drawable类的用例来简单介绍，其它可详细参阅API文档。</p>
<h4 id="Clip-Drawable用例"><a href="#Clip-Drawable用例" class="headerlink" title="Clip Drawable用例"></a>Clip Drawable用例</h4><p>首先有一个图像文件l5.jpg被放置于res/drawable中，另有一个clip drawable资源定义文件res/drawable/clip.xml,内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

   android:drawable=&quot;@drawable/l5&quot;

   android:clipOrientation=&quot;vertical&quot;

   android:gravity=&quot;left&quot; /&gt;
</code></pre><p>该xml资源正好被main.xml中的一个控件ImageView调用，具体如下所示</p>
<pre><code>&lt;ImageView

    android:id=&quot;@+id/clipimage&quot;

    android:background=&quot;@drawable/clip&quot;

    android:layout_height=&quot;wrap_content&quot;

    android:layout_width=&quot;wrap_content&quot; /&gt;
</code></pre><p>假如不在java代码中进行控制，那么ImageView将显示不出背景图像来，我们对其进行如下调用</p>
<pre><code>ImageView clipview = (ImageView) findViewById(R.id.clipimage);

//这里控件用android:background,调用就用getBackgroud函数

ClipDrawable drawable = (ClipDrawable) clipview.getBackground();

drawable.setLevel(drawable.getLevel() + 2000);
</code></pre><p>结果就会在ImageView上显示剪切过了的小图。</p>
<h4 id="Scale-Drawable用例"><a href="#Scale-Drawable用例" class="headerlink" title="Scale Drawable用例"></a>Scale Drawable用例</h4><p>如上例一样，还是那个l5.jpg图片，在res/drawable中定义了一个scale.xml资源文件，具体内容如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

    android:drawable=&quot;@drawable/l5&quot;

    android:scaleGravity=&quot;center_vertical|center_horizontal&quot;

    android:scaleHeight=&quot;80%&quot;

    android:scaleWidth=&quot;80%&quot; /&gt;
</code></pre><p>表示上述图片在资源中就已经被缩放了80%，该资源被main.xml中的另一个Imageview控件使用</p>
<pre><code>&lt;ImageView

   android:id=&quot;@+id/scaleimage&quot;

    android:src=&quot;@drawable/scale&quot;

   android:layout_height=&quot;wrap_content&quot;

   android:layout_width=&quot;wrap_content&quot; /&gt;
</code></pre><p>同样该资源假如不通过代码控制，在用户界面上也是显示不出来的，具体调用代码类似如下：</p>
<pre><code>ImageView scaleview = (ImageView) findViewById(R.id.scaleimage);

//这里控件用android:src,调用就用getDrawable函数

ScaleDrawable scaledrawable = (ScaleDrawable) scaleview.getDrawable();

scaledrawable.setLevel(1000);
</code></pre><p>结果就会在Imageview上显示一个缩小了l5的图像</p>
<h4 id="Shape-Drawable资源用例"><a href="#Shape-Drawable资源用例" class="headerlink" title="Shape Drawable资源用例"></a>Shape Drawable资源用例</h4><p>有一个shapeDrawable资源定义在res/drawable/buttonstyle.xml，具体内容如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;selector

   xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

   &lt;item android:state_pressed=&quot;true&quot; &gt;

       &lt;shape&gt;

           &lt;!-- 渐变 --&gt;

           &lt;gradient

               android:startColor=&quot;#ff8c00&quot;

               android:endColor=&quot;#FFFFFF&quot;

                android:type=&quot;radial&quot;

               android:gradientRadius=&quot;50&quot; /&gt;

           &lt;!-- 描边 --&gt;

           &lt;stroke

                android:width=&quot;2dp&quot;

               android:color=&quot;#dcdcdc&quot;

               android:dashWidth=&quot;5dp&quot;

                android:dashGap=&quot;3dp&quot;/&gt;

           &lt;!-- 圆角 --&gt;

           &lt;corners

                android:radius=&quot;2dp&quot;/&gt;

           &lt;padding

                android:left=&quot;10dp&quot;

                android:top=&quot;10dp&quot;

                android:right=&quot;10dp&quot;

                android:bottom=&quot;10dp&quot;/&gt;

       &lt;/shape&gt;

   &lt;/item&gt;



   &lt;item android:state_focused=&quot;true&quot; &gt;

       &lt;shape&gt;

           &lt;gradient

               android:startColor=&quot;#ffc2b7&quot;

               android:endColor=&quot;#ffc2b7&quot;

                android:angle=&quot;270&quot;/&gt;

           &lt;stroke

               android:width=&quot;2dp&quot;

               android:color=&quot;#dcdcdc&quot; /&gt;

           &lt;corners

                android:radius=&quot;2dp&quot;/&gt;

           &lt;padding

                android:left=&quot;10dp&quot;

                android:top=&quot;10dp&quot;

                android:right=&quot;10dp&quot;

                android:bottom=&quot;10dp&quot;/&gt;

       &lt;/shape&gt;

   &lt;/item&gt;



   &lt;item&gt;      

       &lt;shape&gt;

           &lt;solid android:color=&quot;#ff9d77&quot;/&gt;

           &lt;stroke

                android:width=&quot;2dp&quot;

               android:color=&quot;#fad3cf&quot; /&gt;

            &lt;corners

               android:topRightRadius=&quot;5dp&quot;

               android:bottomLeftRadius=&quot;5dp&quot;

               android:topLeftRadius=&quot;0dp&quot;

               android:bottomRightRadius=&quot;0dp&quot;

           /&gt;

           &lt;padding

                android:left=&quot;10dp&quot;

                android:top=&quot;10dp&quot;

                android:right=&quot;10dp&quot;

                android:bottom=&quot;10dp&quot;/&gt;

       &lt;/shape&gt;

   &lt;/item&gt;

&lt;/selector&gt;
</code></pre><p>该Shape绘制资源，被main.xml中的两个button所调用，代码如下所示</p>
<pre><code>&lt;ImageButton

   android:id=&quot;@+id/button&quot;

   android:src=&quot;@drawable/buttonstyle&quot;

   android:layout_width=&quot;136dp&quot;

   android:layout_height=&quot;110dp&quot;/&gt;

&lt;ImageButton

   android:id=&quot;@+id/button1&quot;

   android:background=&quot;@drawable/buttonstyle&quot;

   android:layout_width=&quot;136dp&quot;

   android:layout_height=&quot;110dp&quot;/&gt;
</code></pre><p>这个就不需要用java代码了</p>
<h3 id="风格和主题资源（style-amp-theme）"><a href="#风格和主题资源（style-amp-theme）" class="headerlink" title="风格和主题资源（style&amp;theme）"></a>风格和主题资源（style&amp;theme）</h3><p>风格和主题的语法其实是一样的，只是运用环境不一样。</p>
<p>Theme是针对窗体级别的，改变窗体样式；</p>
<p>Style是针对窗体元素级别的，改变指定控件或者Layout的样式。</p>
<p>Android系统的themes.xml和style.xml(位于/base/core/res/res/values/)包含了很多系统定义好的style，一般使用系统的就可以了，需要扩展也是建议在里面挑个合适的，然后再继承修改。</p>
<h4 id="风格和主题资源语法"><a href="#风格和主题资源语法" class="headerlink" title="风格和主题资源语法"></a>风格和主题资源语法</h4><p>Style&amp;theme资源定义文件被放置在res/values下面，具体语法形式如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

   &lt;style name=&quot;style_name&quot;

       parent=&quot;@[package:]style/style_to_inherit&quot;&gt;

       &lt;itemname=&quot;[package:]style_property_name&quot;&gt;style_value&lt;/item&gt;

   &lt;/style&gt;

&lt;/resources&gt;
</code></pre><p>调用时可以通过@[package:]style/style_nam或者R.style.style_name来实现。</p>
<h4 id="风格和主题资源用例"><a href="#风格和主题资源用例" class="headerlink" title="风格和主题资源用例"></a>风格和主题资源用例</h4><p>下边是主题的一个例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;

    &lt;style name=&quot;CustomTheme&quot;&gt;

        &lt;itemname=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;

        &lt;item name=&quot;windowFrame&quot;&gt;@drawable/screen_frame&lt;/item&gt;

        &lt;itemname=&quot;windowBackground&quot;&gt;@drawable/screen_background_white&lt;/item&gt;

        &lt;itemname=&quot;panelForegroundColor&quot;&gt;#FF000000&lt;/item&gt;

        &lt;itemname=&quot;panelBackgroundColor&quot;&gt;#FFFFFFFF&lt;/item&gt;

        &lt;itemname=&quot;panelTextColor&quot;&gt;?panelForegroundColor&lt;/item&gt;

        &lt;itemname=&quot;panelTextSize&quot;&gt;14&lt;/item&gt;

        &lt;itemname=&quot;menuItemTextColor&quot;&gt;?panelTextColor&lt;/item&gt;

        &lt;itemname=&quot;menuItemTextSize&quot;&gt;?panelTextSize&lt;/item&gt;

    &lt;/style&gt;

&lt;/resources&gt;
</code></pre><p>我们用了“@”符号和“？”符号来应用资源。“@”符号表明了我们应用的资源是前边定义过的(或者在前一个项目中或者在Android 框架中)。“？”表明了我们引用的资源的值在当前的主题当中定义的。通过引用在<item>里边定义的名字可以做到(panelTextColor 用的颜色和panelForegroundColor中定义的一样 )，这种技巧只能用在XML资源当中。</item></p>
<p>在程序中使用主题的方法有两类，一类是主题应用在一个activity中，可以在Java代码中修改如下：</p>
<pre><code>protected void onCreate(BundlesavedInstanceState)

{

     super.onCreate(savedInstanceState);

     setTheme(R.style.CustomTheme);   

     setContentView(R.layout.linear_layout_3);

}
</code></pre><p>也可以在AndroidManifest.xml中修改具体Activity的主题属性，代码如下</p>
<pre><code>&lt;activityandroid:theme=”@style/CustomTheme”&gt;
</code></pre><p>如果要使主题应用至整个应用，那么就必须在mainfest.xml中应用主题：</p>
<p>打开应用代码的AndroidManifest.xml文件，编辑<application>标签，让其包含android:theme属性，值就是需要调用的主题的名字，代码如下：</application></p>
<pre><code>&lt;applicationandroid:theme=”@style/CustomTheme”&gt;
</code></pre><p>至此我们将Android用到的资源基本都介绍了下，至于res/xml和res/raw文件下的资源，前者通过Resources.getXML()获取资源文件，后者通过Resources.openRawResource()获得资源文件，具体文件解析和处理在这里就不做展开了。</p>
<h3 id="资源文件中一些属性概念的区分"><a href="#资源文件中一些属性概念的区分" class="headerlink" title="资源文件中一些属性概念的区分"></a>资源文件中一些属性概念的区分</h3><p>在资源中有很多相似或者有点容易混淆的属性概念，在这个小结的末尾对碰到的补充说明下。</p>
<h4 id="android-gravity-VS-android-layout-gravity"><a href="#android-gravity-VS-android-layout-gravity" class="headerlink" title="android:gravity VS android:layout_gravity"></a>android:gravity VS android:layout_gravity</h4><p>gravity是用于对齐的标签，其中android:gravity属性是针对控件view内容的限定。比如一个button上面的text，你可以设置该text在view的靠左或靠右等位置，该属性起到这个作用。</p>
<p>android:layout_gravity属性是用来设置该控件相对于父view 的位置的限定。比如一个button在linearlayout里，你想把该button放在靠左或靠右等位置就可以通过该属性来设置。</p>
<h4 id="padding-VS-margin"><a href="#padding-VS-margin" class="headerlink" title="padding VS margin"></a>padding VS margin</h4><p>padding是填充的意思，指的是控件view中的内容（content）与控件view边缘的距离，也即控件内边距的属性关系；而margin表示的是控件外边距的关系，即控件view与ViewGroup的距离关系，在相对布局中控件与控件之间的相对位置距离关系。</p>
<p>目前先小结到这里，对于属性概念方面的内容，后面用到了再继续追加记录。</p>
<h4 id="View的显示状态GONE-VISIBLE和INVISIBLE区别"><a href="#View的显示状态GONE-VISIBLE和INVISIBLE区别" class="headerlink" title="View的显示状态GONE,VISIBLE和INVISIBLE区别"></a>View的显示状态GONE,VISIBLE和INVISIBLE区别</h4><p>很多网友可能会发现View类的设置显示状态setVisibility方法有三种情况，分别为GONE、VISIBLE和INVISIBLE，它们之间到底有哪些区别呢? Android123给大家举个简单的例子。可能很多网友会发现有些Android应用的下面包含了AdMob或Adsense广告条，如果这个View我们设置为GONE则消失，该广告条看不见也不占用位置。而INVISIBLE则代表广告条那块是空白，但仍然沾着他布局高和宽的位置，而VISIBLE 就是标准显示时的状态</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/05/Android 资源（resource）学习小结/" data-id="cip2gakg100011ouurxmw8jgh" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/05/31/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/05/Android 资源（resource）学习小结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/05/31/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>